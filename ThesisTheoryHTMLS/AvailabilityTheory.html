<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head><title>Theory: Availability</title><meta http-equiv="content-type" content="text/html;charset=UTF-8">
<style type="text/css">
<!--
  body {background: #faf0e6; color: #191970; }
  span.freevar  { color: blue}
  span.boundvar { color: green}
  span.typevar  { color: purple}
  span.type     { color: teal}
  span.strong   { color: black; font-weight: bold}
  span.vstrong  { color: black; 
                  font-weight: bold;
                  font-size: larger}
  h1 {color: black}
  th {color: crimson}
-->
</style>
</head>
<body>
<h1>Theory "Availability"</h1>
<span class="vstrong">Parents</span>&nbsp;&nbsp;&nbsp;&nbsp;
    <a href = "VDCTheory.html"><span class="strong">VDC</span></a>&nbsp;&nbsp;
    <a href = "FT_deepTheory.html"><span class="strong">FT_deep</span></a>

<h1>Signature</h1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    Constant
    <th>
    Type<tr><td>
            <span class="strong">AND_unavail_FT_gate</span>
            <td>
            :α event # α event event # (α event -> real) ->
             ((α -> extreal) # (α -> extreal)) list list -> real -> α event
    <tr><td>
        <span class="strong">NAND_unavail_FT_gate</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list list ->
         ((α -> extreal) # (α -> extreal)) list list -> real -> α event
    <tr><td>
        <span class="strong">NOR_unavail_FT_gate</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list list -> real -> α event
    <tr><td>
        <span class="strong">OR_unavail_FT_gate</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list list -> real -> α event
    <tr><td> <span class="strong">UNIONL</span> <td> :α event list -> α event
    <tr><td>
        <span class="strong">XOR_unavail_FT_gate</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list ->
         ((α -> extreal) # (α -> extreal)) list -> real -> α event
    <tr><td>
        <span class="strong">avail_event</span>
        <td>
        :((α -> extreal) # (α -> extreal)) list -> num -> extreal -> α event
    <tr><td>
        <span class="strong">avail_event_list</span>
        <td>
        :((α -> extreal) # (α -> extreal)) list list ->
         num -> extreal -> α event list
    <tr><td>
        <span class="strong">cdf</span>
        <td>
        :α event # α event event # (α event -> real) ->
         (α -> extreal) -> extreal -> real
    <tr><td>
        <span class="strong">compl_steady_state_avail</span>
        <td>
        :(real # real) list -> real
    <tr><td>
        <span class="strong">expec</span>
        <td>
        :num -> (num -> real) -> real
    <tr><td>
        <span class="strong">expec_avail</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list -> num -> extreal -> real
    <tr><td>
        <span class="strong">expec_avail1</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list -> num -> extreal -> real
    <tr><td>
        <span class="strong">inst_avail_exp</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list -> num -> (real # real) event
    <tr><td>
        <span class="strong">inst_avail_exp1</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list -> num -> (real # real) event
    <tr><td>
        <span class="strong">inst_avail_exp2</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list -> (real # real) event
    <tr><td>
        <span class="strong">inst_avail_exp3</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list -> (real # real) event
    <tr><td>
        <span class="strong">inst_avail_exp_list</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list list ->
         num -> (real # real) list event
    <tr><td>
        <span class="strong">inst_avail_exp_list1</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list list ->
         (real # real) list event
    <tr><td>
        <span class="strong">inst_avail_exp_list2</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list list ->
         (real # real) list event
    <tr><td>
        <span class="strong">inst_unavail_exp</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list -> (real # real) event
    <tr><td>
        <span class="strong">inst_unavail_exp_list</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list list ->
         (real # real) list event
    <tr><td>
        <span class="strong">list_union_avail_event_list</span>
        <td>
        :((α -> extreal) # (α -> extreal)) list list list ->
         real -> α event list list
    <tr><td>
        <span class="strong">rel_event1</span>
        <td>
        :α event # α event event # (α event -> real) ->
         (α -> extreal) -> extreal -> α event
    <tr><td>
        <span class="strong">reliability</span>
        <td>
        :α event # α event event # (α event -> real) ->
         (α -> extreal) -> extreal -> real
    <tr><td>
        <span class="strong">steady_state_avail</span>
        <td>
        :real # real -> real
    <tr><td>
        <span class="strong">steady_state_avail_list</span>
        <td>
        :(real # real) list -> real list
    <tr><td>
        <span class="strong">steady_state_avail_prod</span>
        <td>
        :(real # real) list -> real
    <tr><td>
        <span class="strong">steady_state_unavail</span>
        <td>
        :real # real -> real
    <tr><td>
        <span class="strong">steady_state_unavail_list</span>
        <td>
        :(real # real) list -> real list
    <tr><td>
        <span class="strong">two_dim_inst_avail_exp</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list list list ->
         (real # real) list list event
    <tr><td>
        <span class="strong">two_dim_inst_unavail_exp</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list list list ->
         (real # real) list list event
    <tr><td>
        <span class="strong">two_dim_steady_state_avail_list</span>
        <td>
        :(real # real) list list -> real list list
    <tr><td>
        <span class="strong">two_dim_steady_state_avail_prod</span>
        <td>
        :(real # real) list list -> real
    <tr><td>
        <span class="strong">unavail_event</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list -> num -> extreal -> α event
    <tr><td>
        <span class="strong">union_avail_event_list</span>
        <td>
        :((α -> extreal) # (α -> extreal)) list list ->
         num -> real -> α event list
    <tr><td>
        <span class="strong">union_avail_event_list1</span>
        <td>
        :((α -> extreal) # (α -> extreal)) list list -> real -> α event list
    <tr><td>
        <span class="strong">union_avail_events</span>
        <td>
        :((α -> extreal) # (α -> extreal)) list -> num -> real -> α event
    <tr><td>
        <span class="strong">union_avail_events1</span>
        <td>
        :((α -> extreal) # (α -> extreal)) list -> real -> α event
    <tr><td>
        <span class="strong">union_unavail_event_list</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list list -> real -> α event list
    <tr><td>
        <span class="strong">union_unavail_events</span>
        <td>
        :α event # α event event # (α event -> real) ->
         ((α -> extreal) # (α -> extreal)) list -> real -> α event

</table>
</center>

<h1>Definitions</h1>
<DL>
<DT><span class="strong">UNIONL_def</span>
<DD>
<pre>
|- (UNIONL [] = ∅) ∧ ∀s ss. UNIONL (s::ss) = s ∪ UNIONL ss
</pre>

<DT><span class="strong">avail_event_def</span>
<DD>
<pre>
|- ∀L n t.
     avail_event L n t =
     {x |
      SIGMA (λa. FST (EL a L) x + SND (EL a L) x) (count n) ≤ t ∧
      t <
      SIGMA (λa. FST (EL a L) x + SND (EL a L) x) (count n) + FST (EL n L) x}
</pre>

<DT><span class="strong">union_avail_events_def</span>
<DD>
<pre>
|- ∀L n t.
     union_avail_events L n t =
     BIGUNION (IMAGE (λa. avail_event L a (Normal t)) (count n))
</pre>

<DT><span class="strong">union_avail_events1_def</span>
<DD>
<pre>
|- ∀L t.
     union_avail_events1 L t =
     BIGUNION (IMAGE (λa. avail_event L a (Normal t)) (count (LENGTH L)))
</pre>

<DT><span class="strong">union_avail_event_list_def</span>
<DD>
<pre>
|- ∀L n t. union_avail_event_list L n t = MAP (λa. union_avail_events a n t) L
</pre>

<DT><span class="strong">union_avail_event_list1_def</span>
<DD>
<pre>
|- ∀L t. union_avail_event_list1 L t = MAP (λa. union_avail_events1 a t) L
</pre>

<DT><span class="strong">list_union_avail_event_list_def</span>
<DD>
<pre>
|- ∀L t.
     list_union_avail_event_list L t = MAP (λa. union_avail_event_list1 a t) L
</pre>

<DT><span class="strong">avail_event_list_def</span>
<DD>
<pre>
|- ∀L n t. avail_event_list L n t = MAP (λa. avail_event a n t) L
</pre>

<DT><span class="strong">expec_avail_def</span>
<DD>
<pre>
|- ∀p L n t. expec_avail p L n t = sum (0,n) (λa. prob p (avail_event L a t))
</pre>

<DT><span class="strong">expec_avail1_def</span>
<DD>
<pre>
|- ∀p L n t.
     expec_avail1 p L n t = sum (0,n) (prob p o (λa. avail_event L a t))
</pre>

<DT><span class="strong">cdf_def</span>
<DD>
<pre>
|- ∀p X t. cdf p X t = distribution p X {y | y ≤ t}
</pre>

<DT><span class="strong">reliability_def</span>
<DD>
<pre>
|- ∀p X t. reliability p X t = 1 − cdf p X t
</pre>

<DT><span class="strong">rel_event1_def</span>
<DD>
<pre>
|- ∀p X t. rel_event1 p X t = PREIMAGE X {y | t < y} ∩ p_space p
</pre>

<DT><span class="strong">expec_def</span>
<DD>
<pre>
|- ∀n f. expec n f = sum (0,n) f
</pre>

<DT><span class="strong">inst_avail_exp_def</span>
<DD>
<pre>
|- ∀p L n m.
     inst_avail_exp p L n m ⇔
     ∀t.
       expec n (λa. prob p (avail_event L a (Normal t))) =
       SND m / (SND m + FST m) +
       FST m / (SND m + FST m) * exp (-(SND m + FST m) * t)
</pre>

<DT><span class="strong">inst_avail_exp1_def</span>
<DD>
<pre>
|- ∀p L n m.
     inst_avail_exp1 p L n m ⇔
     ∀t.
       prob p (union_avail_events L n (&t)) =
       SND m / (SND m + FST m) +
       FST m / (SND m + FST m) * exp (-(SND m + FST m) * &t)
</pre>

<DT><span class="strong">inst_avail_exp2_def</span>
<DD>
<pre>
|- ∀p L m.
     inst_avail_exp2 p L m ⇔
     ∀t.
       prob p (union_avail_events1 L (&t)) =
       SND m / (SND m + FST m) +
       FST m / (SND m + FST m) * exp (-(SND m + FST m) * &t)
</pre>

<DT><span class="strong">inst_avail_exp3_def</span>
<DD>
<pre>
|- ∀p L m.
     inst_avail_exp3 p L m ⇔
     ∀t.
       prob p (union_avail_events1 L (&t) ∩ p_space p) =
       SND m / (SND m + FST m) +
       FST m / (SND m + FST m) * exp (-(SND m + FST m) * &t)
</pre>

<DT><span class="strong">inst_avail_exp_list_def</span>
<DD>
<pre>
|- (∀p n M. inst_avail_exp_list p [] n M ⇔ T) ∧
   ∀p h t n M.
     inst_avail_exp_list p (h::t) n M ⇔
     inst_avail_exp p h n (HD M) ∧ inst_avail_exp_list p t n (TL M)
</pre>

<DT><span class="strong">inst_avail_exp_list1_def</span>
<DD>
<pre>
|- (∀p M. inst_avail_exp_list1 p [] M ⇔ T) ∧
   ∀p h t M.
     inst_avail_exp_list1 p (h::t) M ⇔
     inst_avail_exp2 p h (HD M) ∧ inst_avail_exp_list1 p t (TL M)
</pre>

<DT><span class="strong">inst_avail_exp_list2_def</span>
<DD>
<pre>
|- (∀p M. inst_avail_exp_list2 p [] M ⇔ T) ∧
   ∀p h t M.
     inst_avail_exp_list2 p (h::t) M ⇔
     inst_avail_exp3 p h (HD M) ∧ inst_avail_exp_list2 p t (TL M)
</pre>

<DT><span class="strong">two_dim_inst_avail_exp_def</span>
<DD>
<pre>
|- (∀p M. two_dim_inst_avail_exp p [] M ⇔ T) ∧
   ∀p h t M.
     two_dim_inst_avail_exp p (h::t) M ⇔
     inst_avail_exp_list1 p h (HD M) ∧ two_dim_inst_avail_exp p t (TL M)
</pre>

<DT><span class="strong">steady_state_avail_def</span>
<DD>
<pre>
|- ∀m. steady_state_avail m = SND m / (SND m + FST m)
</pre>

<DT><span class="strong">steady_state_avail_list_def</span>
<DD>
<pre>
|- (steady_state_avail_list [] = []) ∧
   ∀h t.
     steady_state_avail_list (h::t) =
     steady_state_avail h::steady_state_avail_list t
</pre>

<DT><span class="strong">two_dim_steady_state_avail_list_def</span>
<DD>
<pre>
|- (two_dim_steady_state_avail_list [] = []) ∧
   ∀h t.
     two_dim_steady_state_avail_list (h::t) =
     steady_state_avail_list h::two_dim_steady_state_avail_list t
</pre>

<DT><span class="strong">steady_state_avail_prod_def</span>
<DD>
<pre>
|- (steady_state_avail_prod [] = 1) ∧
   ∀h t.
     steady_state_avail_prod (h::t) =
     steady_state_avail h * steady_state_avail_prod t
</pre>

<DT><span class="strong">two_dim_steady_state_avail_prod_def</span>
<DD>
<pre>
|- (two_dim_steady_state_avail_prod [] = 1) ∧
   ∀h t.
     two_dim_steady_state_avail_prod (h::t) =
     steady_state_avail_prod h * two_dim_steady_state_avail_prod t
</pre>

<DT><span class="strong">compl_steady_state_avail_def</span>
<DD>
<pre>
|- (compl_steady_state_avail [] = 1) ∧
   ∀h t.
     compl_steady_state_avail (h::t) =
     (1 − steady_state_avail h) * compl_steady_state_avail t
</pre>

<DT><span class="strong">unavail_event_def</span>
<DD>
<pre>
|- ∀p L n t.
     unavail_event p L n t = p_space p DIFF avail_event L n t ∩ p_space p
</pre>

<DT><span class="strong">union_unavail_events_def</span>
<DD>
<pre>
|- ∀p L t.
     union_unavail_events p L t =
     p_space p DIFF union_avail_events1 L t ∩ p_space p
</pre>

<DT><span class="strong">union_unavail_event_list_def</span>
<DD>
<pre>
|- ∀p L t.
     union_unavail_event_list p L t = MAP (λa. union_unavail_events p a t) L
</pre>

<DT><span class="strong">steady_state_unavail_def</span>
<DD>
<pre>
|- ∀m. steady_state_unavail m = FST m / (SND m + FST m)
</pre>

<DT><span class="strong">steady_state_unavail_list_def</span>
<DD>
<pre>
|- ∀M. steady_state_unavail_list M = MAP (λa. steady_state_unavail a) M
</pre>

<DT><span class="strong">inst_unavail_exp_def</span>
<DD>
<pre>
|- ∀p L m.
     inst_unavail_exp p L m ⇔
     ∀t.
       prob p (union_unavail_events p L (&t)) =
       FST m / (SND m + FST m) −
       FST m / (SND m + FST m) * exp (-(SND m + FST m) * &t)
</pre>

<DT><span class="strong">inst_unavail_exp_list_def</span>
<DD>
<pre>
|- (∀p M. inst_unavail_exp_list p [] M ⇔ T) ∧
   ∀p h t M.
     inst_unavail_exp_list p (h::t) M ⇔
     inst_unavail_exp p h (HD M) ∧ inst_unavail_exp_list p t (TL M)
</pre>

<DT><span class="strong">two_dim_inst_unavail_exp_def</span>
<DD>
<pre>
|- (∀p M. two_dim_inst_unavail_exp p [] M ⇔ T) ∧
   ∀p h t M.
     two_dim_inst_unavail_exp p (h::t) M ⇔
     inst_unavail_exp_list p h (HD M) ∧ two_dim_inst_unavail_exp p t (TL M)
</pre>

<DT><span class="strong">AND_unavail_FT_gate_def</span>
<DD>
<pre>
|- ∀p L t.
     AND_unavail_FT_gate p L t =
     FTree p (AND (gate_list (union_unavail_event_list p L t)))
</pre>

<DT><span class="strong">OR_unavail_FT_gate_def</span>
<DD>
<pre>
|- ∀p L t.
     OR_unavail_FT_gate p L t =
     FTree p (OR (gate_list (union_unavail_event_list p L t)))
</pre>

<DT><span class="strong">NOR_unavail_FT_gate_def</span>
<DD>
<pre>
|- ∀p L t.
     NOR_unavail_FT_gate p L t =
     p_space p DIFF FTree p (OR (gate_list (union_unavail_event_list p L t)))
</pre>

<DT><span class="strong">NAND_unavail_FT_gate_def</span>
<DD>
<pre>
|- ∀p L1 L2 t.
     NAND_unavail_FT_gate p L1 L2 t =
     FTree p
       (AND
          (gate_list
             (compl_list p (union_unavail_event_list p L1 t) ++
              union_unavail_event_list p L2 t)))
</pre>

<DT><span class="strong">XOR_unavail_FT_gate_def</span>
<DD>
<pre>
|- ∀p X Y t.
     XOR_unavail_FT_gate p X Y t =
     XOR_FT_gate p (atomic (union_unavail_events p X t))
       (atomic (union_unavail_events p Y t))
</pre>

</DL>


<hr>

<hr>
<h1>Theorems</h1>
<DL>
<DT><span class="strong">in_events_normal_events</span>
<DD>
<pre>
|- ∀p A t.
     prob_space p ∧ p_space p DIFF A ∩ p_space p ∈ events p ⇒
     A ∩ p_space p ∈ events p
</pre>

<DT><span class="strong">steady_state_NOR_unavail_FT_gate</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z M ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧
     (∀t'.
        ¬NULL (union_unavail_event_list p L (&t')) ∧
        (∀z. MEM z (union_unavail_event_list p L (&t')) ⇒ z ∈ events p) ∧
        mutual_indep p (union_unavail_event_list p L (&t'))) ∧
     inst_unavail_exp_list p L M ⇒
     (lim (λt. prob p (NOR_unavail_FT_gate p L (&t))) =
      list_prod (one_minus_list (steady_state_unavail_list M)))
</pre>

<DT><span class="strong">OR_steady_state_unavail</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z M ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧
     (∀t'.
        ¬NULL (union_unavail_event_list p L (&t')) ∧
        (∀z. MEM z (union_unavail_event_list p L (&t')) ⇒ z ∈ events p) ∧
        mutual_indep p (union_unavail_event_list p L (&t'))) ∧
     inst_unavail_exp_list p L M ⇒
     (lim (λt. prob p (OR_unavail_FT_gate p L (&t))) =
      1 − list_prod (one_minus_list (steady_state_unavail_list M)))
</pre>

<DT><span class="strong">IN_UNIONL</span>
<DD>
<pre>
|- ∀l v. v ∈ UNIONL l ⇔ ∃s. MEM s l ∧ v ∈ s
</pre>

<DT><span class="strong">compl_rel_event_eq_fail_event1</span>
<DD>
<pre>
|- ∀p t s.
     prob_space p ⇒
     (p_space p DIFF PREIMAGE s {y | t < y} ∩ p_space p =
      PREIMAGE s {y | y ≤ t} ∩ p_space p)
</pre>

<DT><span class="strong">compl_fail_event_eq_rel_event1</span>
<DD>
<pre>
|- ∀X t p.
     p_space p DIFF PREIMAGE X {y | y ≤ t} ∩ p_space p = rel_event1 p X t
</pre>

<DT><span class="strong">avail_ge_rel</span>
<DD>
<pre>
|- ∀p t L.
     0 ≤ t ∧ ¬NULL L ∧ (∀n. avail_event L n t ∈ events p) ∧ prob_space p ⇒
     reliability p (FST (HD L)) t ≤ expec_avail p L (LENGTH L) t
</pre>

<DT><span class="strong">avail_ge_rel1</span>
<DD>
<pre>
|- ∀p t L.
     0 ≤ Normal t ∧ ¬NULL L ∧
     (∀a b.
        a ≠ b ⇒
        DISJOINT (avail_event L a (Normal t)) (avail_event L b (Normal t))) ∧
     (∀n. avail_event L n (Normal t) ∈ events p) ∧ prob_space p ⇒
     reliability p (FST (HD L)) (Normal t) ≤
     prob p (union_avail_events L (LENGTH L) t)
</pre>

<DT><span class="strong">neg_exp_tend0_new</span>
<DD>
<pre>
|- ∀t c. 0 < c ⇒ (λt. exp (&t * -c)) --> 0
</pre>

<DT><span class="strong">steady_avail_temp</span>
<DD>
<pre>
|- ∀a b. 0 < a ∧ 0 < b ⇒ 0 < a + b
</pre>

<DT><span class="strong">steady_state_avail</span>
<DD>
<pre>
|- ∀p L n m t.
     (0 < FST m ∧ 0 < SND m) ∧ inst_avail_exp p L n m ⇒
     (lim (λt. expec_avail p L n (Normal (&t))) = SND m / (SND m + FST m))
</pre>

<DT><span class="strong">steady_state_avail1</span>
<DD>
<pre>
|- ∀p L n m.
     prob_space p ∧
     (∀t.
        (∀a b.
           a ≠ b ⇒
           DISJOINT (avail_event L a (Normal t))
             (avail_event L b (Normal t))) ∧
        ∀n. avail_event L n (Normal t) ∈ events p) ∧ (0 < FST m ∧ 0 < SND m) ∧
     inst_avail_exp p L n m ⇒
     (lim (λt. prob p (union_avail_events L n (&t))) =
      SND m / (SND m + FST m))
</pre>

<DT><span class="strong">EXT_LE_LT</span>
<DD>
<pre>
|- ∀x y. x ≤ y ∨ y < x ⇔ (x = y) ∨ x < y ∨ y < x
</pre>

<DT><span class="strong">PERM_refl</span>
<DD>
<pre>
|- ∀L. PERM L L
</pre>

<DT><span class="strong">LET_ANTISYM</span>
<DD>
<pre>
|- ∀x y. ¬(x < y ∧ y ≤ x)
</pre>

<DT><span class="strong">not_null_leng</span>
<DD>
<pre>
|- ∀L1. ¬NULL L1 ⇒ 1 ≤ LENGTH L1
</pre>

<DT><span class="strong">series_expec_tends_prod_avail</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z M ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧ inst_avail_exp_list1 p L M ⇒
     (λt. list_prod (list_prob p (union_avail_event_list1 L (&t)))) -->
     steady_state_avail_prod M
</pre>

<DT><span class="strong">series_rbd_avail</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z M ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧
     (∀t'.
        ¬NULL (union_avail_event_list1 L (&t')) ∧
        (∀z. MEM z (union_avail_event_list1 L (&t')) ⇒ z ∈ events p) ∧
        mutual_indep p (union_avail_event_list1 L (&t'))) ∧
     inst_avail_exp_list1 p L M ⇒
     (lim
        (λt.
           prob p
             (rbd_struct p
                (series (rbd_list (union_avail_event_list1 L (&t)))))) =
      steady_state_avail_prod M)
</pre>

<DT><span class="strong">lim_inst_parall_tend_steady</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z M ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧ inst_avail_exp_list1 p L M ⇒
     (λt.
        list_prod
          (one_minus_list (list_prob p (union_avail_event_list1 L (&t))))) -->
     compl_steady_state_avail M
</pre>

<DT><span class="strong">compl_steady_state_avail_equi</span>
<DD>
<pre>
|- ∀M.
     compl_steady_state_avail M =
     list_prod (one_minus_list (steady_state_avail_list M))
</pre>

<DT><span class="strong">parallel_rbd_avail</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z M ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧
     (∀t'.
        ¬NULL (union_avail_event_list1 L (&t')) ∧
        (∀z. MEM z (union_avail_event_list1 L (&t')) ⇒ z ∈ events p) ∧
        mutual_indep p (union_avail_event_list1 L (&t'))) ∧
     inst_avail_exp_list1 p L M ⇒
     (lim
        (λt.
           prob p
             (rbd_struct p
                (parallel (rbd_list (union_avail_event_list1 L (&t)))))) =
      1 − list_prod (one_minus_list (steady_state_avail_list M)))
</pre>

<DT><span class="strong">lim_inst_parall_series_tend_steady</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z (FLAT M) ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧
     (∀n. n < LENGTH L ⇒ (LENGTH (EL n L) = LENGTH (EL n M))) ∧
     two_dim_inst_avail_exp p L M ⇒
     (λt.
        (list_prod o one_minus_list of (λa. list_prod (list_prob p a)))
          (list_union_avail_event_list L (&t))) -->
     list_prod (one_minus_list (MAP (λa. steady_state_avail_prod a) M))
</pre>

<DT><span class="strong">steady_state_parallel_series_ABD</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z (FLAT M) ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧
     (∀n. n < LENGTH L ⇒ (LENGTH (EL n L) = LENGTH (EL n M))) ∧
     (∀t'.
        (∀z. MEM z (list_union_avail_event_list L (&t')) ⇒ ¬NULL z) ∧
        (∀z.
           MEM z (FLAT (list_union_avail_event_list L (&t'))) ⇒
           z ∈ events p) ∧
        mutual_indep p (FLAT (list_union_avail_event_list L (&t')))) ∧
     two_dim_inst_avail_exp p L M ⇒
     (lim
        (λt.
           prob p
             (rbd_struct p
                ((parallel of (λa. series (rbd_list a)))
                   (list_union_avail_event_list L (&t))))) =
      1 − list_prod (one_minus_list (MAP (λa. steady_state_avail_prod a) M)))
</pre>

<DT><span class="strong">lim_inst_series_parall_tend_steady</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z (FLAT M) ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧
     (∀n. n < LENGTH L ⇒ (LENGTH (EL n L) = LENGTH (EL n M))) ∧
     two_dim_inst_avail_exp p L M ⇒
     (λt.
        (list_prod of (λa. 1 − list_prod (one_minus_list (list_prob p a))))
          (list_union_avail_event_list L (&t))) -->
     list_prod (one_minus_list (MAP (λa. compl_steady_state_avail a) M))
</pre>

<DT><span class="strong">steady_state_series_parallel_avail</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z (FLAT M) ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧
     (∀n. n < LENGTH L ⇒ (LENGTH (EL n L) = LENGTH (EL n M))) ∧
     (∀t'.
        (∀z. MEM z (list_union_avail_event_list L (&t')) ⇒ ¬NULL z) ∧
        (∀z.
           MEM z (FLAT (list_union_avail_event_list L (&t'))) ⇒
           z ∈ events p) ∧
        mutual_indep p (FLAT (list_union_avail_event_list L (&t')))) ∧
     two_dim_inst_avail_exp p L M ⇒
     (lim
        (λt.
           prob p
             (rbd_struct p
                ((series of (λa. parallel (rbd_list a)))
                   (list_union_avail_event_list L (&t))))) =
      list_prod (one_minus_list (MAP (λa. compl_steady_state_avail a) M)))
</pre>

<DT><span class="strong">AND_inst_avail_prod_tends_steady</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z M ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧ inst_unavail_exp_list p L M ⇒
     (λt. list_prod (list_prob p (union_unavail_event_list p L (&t)))) -->
     list_prod (steady_state_unavail_list M)
</pre>

<DT><span class="strong">AND_gate_unavail</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z M ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧
     (∀t'.
        ¬NULL (union_unavail_event_list p L (&t')) ∧
        (∀z. MEM z (union_unavail_event_list p L (&t')) ⇒ z ∈ events p) ∧
        mutual_indep p (union_unavail_event_list p L (&t'))) ∧
     inst_unavail_exp_list p L M ⇒
     (lim (λt. prob p (AND_unavail_FT_gate p L (&t))) =
      list_prod (steady_state_unavail_list M))
</pre>

<DT><span class="strong">lim_inst_OR_tend_steady</span>
<DD>
<pre>
|- ∀p L M.
     prob_space p ∧ (∀z. MEM z M ⇒ 0 < FST z ∧ 0 < SND z) ∧
     (LENGTH L = LENGTH M) ∧
     (∀t' z. MEM z (union_unavail_event_list p L (&t')) ⇒ z ∈ events p) ∧
     inst_avail_exp_list2 p L M ⇒
     (λt.
        list_prod
          (list_prob p
             (compl_list p (union_unavail_event_list p L (&t))))) -->
     list_prod (steady_state_avail_list M)
</pre>

<DT><span class="strong">NAND_steady_state_avail</span>
<DD>
<pre>
|- ∀p L1 L2 M1 M2.
     prob_space p ∧ (∀z. MEM z (M1 ++ M2) ⇒ 0 < FST z ∧ 0 < SND z) ∧
     ((LENGTH L1 = LENGTH M1) ∧ (LENGTH L2 = LENGTH M2)) ∧
     (∀t'.
        1 ≤
        LENGTH
          (union_unavail_event_list p L1 (&t') ++
           union_unavail_event_list p L2 (&t')) ∧
        (∀z.
           MEM z
             (union_unavail_event_list p L1 (&t') ++
              union_unavail_event_list p L2 (&t')) ⇒
           z ∈ events p) ∧
        mutual_indep p
          (union_unavail_event_list p L1 (&t') ++
           union_unavail_event_list p L2 (&t'))) ∧
     inst_avail_exp_list2 p L1 M1 ∧ inst_unavail_exp_list p L2 M2 ⇒
     (lim (λt. prob p (NAND_unavail_FT_gate p L1 L2 (&t))) =
      list_prod (steady_state_avail_list M1) *
      list_prod (steady_state_unavail_list M2))
</pre>

<DT><span class="strong">inst_XOR_tends_steadty</span>
<DD>
<pre>
|- ∀p X1 m1.
     inst_unavail_exp p X1 m1 ∧ 0 < FST m1 ∧ 0 < SND m1 ⇒
     (λt. prob p (union_unavail_events p X1 (&t))) --> steady_state_unavail m1
</pre>

<DT><span class="strong">XOR_steady_unavail</span>
<DD>
<pre>
|- ∀p X1 X2 m1 m2 t.
     prob_space p ∧
     (∀t'.
        union_unavail_events p X1 (&t') ∈ events p ∧
        union_unavail_events p X2 (&t') ∈ events p ∧
        indep p (union_unavail_events p X1 (&t'))
          (union_unavail_events p X2 (&t'))) ∧ (0 < FST m1 ∧ 0 < SND m1) ∧
     (0 < FST m2 ∧ 0 < SND m2) ∧ inst_unavail_exp p X1 m1 ∧
     inst_unavail_exp p X2 m2 ⇒
     (lim
        (λt.
           prob p
             (XOR_FT_gate p (atomic (union_unavail_events p X1 (&t)))
                (atomic (union_unavail_events p X2 (&t))))) =
      steady_state_unavail m1 * (1 − steady_state_unavail m2) +
      steady_state_unavail m2 * (1 − steady_state_unavail m1))
</pre>

</DL>



<hr>
</body>
</html>
